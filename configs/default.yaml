# 1SEC Default Configuration
# All modules are enabled by default with sane defaults.
# Override any setting below or pass --config <path> to use a custom file.
# Run '1sec init' to generate a fresh config, or '1sec modules' to list all modules.

server:
  host: "0.0.0.0"
  port: 1780
  # API key authentication — set one or more keys to secure the REST API.
  # If empty, the API runs in open mode (no auth required).
  # Can also be set via ONESEC_API_KEY environment variable.
  # api_keys:
  #   - "your-secret-api-key-here"
  #
  # Read-only API keys — can only access GET endpoints (dashboards, monitoring).
  # Cannot ingest events, clear alerts, change enforcement, or trigger shutdown.
  # read_only_keys:
  #   - "your-dashboard-readonly-key"
  #
  # CORS — restrict allowed origins for the REST API.
  # In production these should match your dashboard domain(s).
  # Can also be set via ONESEC_CORS_ORIGINS environment variable (comma-separated).
  cors_origins:
    - "https://1-sec.netlify.app"
    - "https://1-sec.dev"
    - "https://www.1-sec.dev"
  # TLS — enable HTTPS on the API server.
  # Provide paths to a PEM-encoded certificate and private key.
  # When configured, the API server uses ListenAndServeTLS.
  # tls_cert: "/etc/1sec/tls/server.crt"
  # tls_key:  "/etc/1sec/tls/server.key"

bus:
  url: "nats://127.0.0.1:4222"
  embedded: true
  data_dir: "./data/nats"
  port: 4222
  cluster_id: "1sec-cluster"

alerts:
  max_store: 10000
  enable_console: true
  # webhook_urls:
  #   - "https://hooks.slack.com/services/YOUR/WEBHOOK/URL"

# Syslog ingestion — receive events from syslog sources (firewalls, servers, etc.)
syslog:
  enabled: false
  protocol: "udp"    # "udp", "tcp", or "both"
  host: "0.0.0.0"
  port: 1514

logging:
  level: "info"       # debug, info, warn, error
  format: "console"   # console, json

# ── Tier 1: Network & Perimeter ──────────────────────────────────────────────

modules:
  network_guardian:
    enabled: true
    settings:
      max_requests_per_minute: 1000
      burst_size: 100
      # geo_mode: "block"
      # blocked_countries: "XX,YY"

  api_fortress:
    enabled: true
    settings:
      api_max_rpm: 200

  iot_shield:
    enabled: true

# ── Tier 2: Application Layer ────────────────────────────────────────────────

  injection_shield:
    enabled: true

  supply_chain:
    enabled: true

  ransomware:
    enabled: true
    settings:
      encryption_threshold: 10
      exfil_mb_threshold: 100

# ── Tier 3: Identity & Access ────────────────────────────────────────────────

  auth_fortress:
    enabled: true
    settings:
      max_failures_per_minute: 10
      lockout_duration_seconds: 300
      stuffing_threshold: 50

  deepfake_shield:
    enabled: true

  identity_monitor:
    enabled: true

# ── Tier 4: AI-Specific Defense ──────────────────────────────────────────────

  llm_firewall:
    enabled: true
    settings:
      token_budget_per_hour: 100000

  ai_containment:
    enabled: true

  data_poisoning:
    enabled: true

# ── Tier 5: Cryptography ────────────────────────────────────────────────────

  quantum_crypto:
    enabled: true

# ── Tier 6: Runtime & Infrastructure ─────────────────────────────────────────

  runtime_watcher:
    enabled: true
    settings:
      scan_interval_seconds: 300

  cloud_posture:
    enabled: true

# ── Cross-Cutting: AI Analysis ───────────────────────────────────────────────

  ai_analysis_engine:
    enabled: true
    settings:
      # gemini_api_key: "YOUR_GEMINI_API_KEY"
      # Also reads from env: GEMINI_API_KEY
      triage_model: "gemini-flash-lite-latest"
      deep_model: "gemini-flash-latest"
      api_base_url: "https://generativelanguage.googleapis.com/v1beta/models"
      triage_workers: 4
      deep_workers: 2

# ── Rust Engine (optional high-performance sidecar) ──────────────────────────
# The Rust sidecar is OPTIONAL. The Go binary is fully self-contained and
# production-ready without it. Enable this only if you have the 1sec-engine
# Rust binary installed and want high-throughput pattern matching or packet capture.

rust_engine:
  enabled: false
  binary: "1sec-engine"
  workers: 0               # 0 = auto-detect CPU cores
  buffer_size: 10000
  min_score: 0.1
  aho_corasick_prefilter: true
  capture:
    enabled: false
    interface: "eth0"
    bpf_filter: ""
    promiscuous: true
    # NOTE: Capture mode requires the Rust sidecar binary (1sec-engine) which is
    # built separately from the Go binary. When enabled, the sidecar performs
    # high-throughput packet capture via libpcap and emits canonical events to
    # NATS. The Go engine manages the sidecar lifecycle (start/stop/health).
    # Without the Rust binary, all other features work — capture is the "power
    # user" upgrade for environments that need wire-level visibility.

# ── Enforcement / Automated Response ─────────────────────────────────────────
# The enforcement layer subscribes to alerts and executes configurable response
# actions. Start in dry_run mode to audit what would happen before going live.
#
# Action types:
#   block_ip         — add IP to system firewall deny rules (auto-unblock after duration)
#   kill_process     — terminate a malicious process by PID or name
#   quarantine_file  — move suspicious file to quarantine directory
#   drop_connection  — reset/drop active network connections from source
#   disable_user     — disable a user account (OS-level or custom command)
#   webhook          — POST alert + action context to a URL (SIEM, Slack, PagerDuty)
#   command          — run an arbitrary shell command with alert template variables
#   log_only         — record the alert without taking enforcement action
#
# Template variables for 'command' action:
#   {{alert_id}}, {{module}}, {{severity}}, {{source_ip}}, {{title}}

enforcement:
  enabled: true
  dry_run: true             # IMPORTANT: start in dry-run to audit before going live
  preset: "safe"            # "lax", "safe", "balanced", or "strict"
                            # lax:      log + webhook only, never blocks/kills
                            # safe:     log + webhook, block_ip only for brute force + port scans (recommended first deploy)
                            # balanced: blocks IPs on HIGH, kills on CRITICAL
                            # strict:   aggressive enforcement on MEDIUM+, short cooldowns
  global_allow_list: []     # IPs that are never blocked (e.g., monitoring, VPN, load balancers)
  # To switch presets via CLI:  1sec enforce preset strict --dry-run
  # To see what a preset does:  1sec enforce preset balanced --show

  # Override individual module policies below. These merge on top of the preset.
  # Any module not listed here uses the preset defaults.
  # Uncomment and customize as needed:
  #
  # policies:
  #   network_guardian:
  #     enabled: true
  #     min_severity: "HIGH"
  #     cooldown_seconds: 300
  #     max_actions_per_min: 20
  #     allow_list: ["10.0.0.1"]    # per-module allow list
  #     actions:
  #       - action: block_ip
  #         min_severity: "HIGH"
  #         description: "Block source IP via system firewall"
  #         params:
  #           duration: "1h"
  #       - action: webhook
  #         min_severity: "CRITICAL"
  #         description: "Notify SOC team"
  #         params:
  #           url: "https://hooks.slack.com/services/YOUR/WEBHOOK/URL"
  #           auth_token: ""
  #       - action: command
  #         min_severity: "CRITICAL"
  #         description: "Run custom remediation script"
  #         params:
  #           command: "/opt/1sec/scripts/block-ip.sh {{source_ip}}"
  #           timeout: "30s"

# ── Cold Archive — indefinite retention ──────────────────────────────────────
# The archiver subscribes to all events, alerts, and responses with a separate
# durable consumer and writes compressed NDJSON files for cold retention.
# JetStream remains the "hot buffer" (7-30 days); the archive is forever.
#
# Files are rotated by size or time interval. To restore a time window for
# investigation, gunzip the file and POST events back via /api/v1/events.

archive:
  enabled: false              # enable cold archiver
  dir: "./data/archive"       # directory for archive files
  rotate_bytes: 104857600     # rotate after 100MB (bytes)
  rotate_interval: "1h"       # rotate after 1 hour
  compress: true              # gzip compress (recommended)
  # Sampling rules — reduce archive volume for high-frequency, low-severity events.
  # Each rule keeps 1 in N events matching the criteria. Events above max_severity
  # are always kept. Alerts and responses are never sampled.
  # sample_rules:
  #   - event_type: "dns_query"
  #     max_severity: "INFO"
  #     sample_rate: 100        # keep 1% of INFO-level dns_query events
  #   - event_type: "http_request"
  #     max_severity: "LOW"
  #     sample_rate: 10         # keep 10% of LOW-or-below http_request events

# ── Reference Collectors — built-in log tailers ──────────────────────────────
# Collectors tail log files and emit canonical schema events to the bus.
# They run inside the 1SEC binary — no external agents needed.
#
# Standalone usage (connects to running 1SEC instance):
#   1sec collect nginx  --log-path /var/log/nginx/access.log
#   1sec collect auth   --log-path /var/log/auth.log
#   1sec collect pfsense --log-path /var/log/filterlog.log
#   1sec collect json   --log-path /var/log/cloudtrail.json
#
# Supported types:
#   nginx    — nginx/apache combined access logs → http_request events
#   auth     — /var/log/auth.log → auth_failure, auth_success, session_activity
#   pfsense  — pfSense/OPNsense filterlog → network_connection events
#   json     — JSON-line logs (CloudTrail, k8s audit) → auto-classified events
