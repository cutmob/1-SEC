package core

import (
	"encoding/json"
	"strings"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/rs/zerolog"
)

// AlertStatus represents the lifecycle state of an alert.
type AlertStatus int

const (
	AlertStatusOpen AlertStatus = iota
	AlertStatusAcknowledged
	AlertStatusResolved
	AlertStatusFalsePositive
)

func (s AlertStatus) String() string {
	switch s {
	case AlertStatusOpen:
		return "OPEN"
	case AlertStatusAcknowledged:
		return "ACKNOWLEDGED"
	case AlertStatusResolved:
		return "RESOLVED"
	case AlertStatusFalsePositive:
		return "FALSE_POSITIVE"
	default:
		return "UNKNOWN"
	}
}

func (s AlertStatus) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.String())
}

// Alert represents a security alert generated by a module.
type Alert struct {
	ID          string                 `json:"id"`
	Timestamp   time.Time              `json:"timestamp"`
	Module      string                 `json:"module"`
	Type        string                 `json:"type"`
	Severity    Severity               `json:"severity"`
	Status      AlertStatus            `json:"status"`
	Title       string                 `json:"title"`
	Description string                 `json:"description"`
	EventIDs    []string               `json:"event_ids"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
	Mitigations []string               `json:"mitigations,omitempty"`
}

// NewAlert creates a new Alert from a SecurityEvent.
func NewAlert(event *SecurityEvent, title, description string) *Alert {
	return &Alert{
		ID:          uuid.New().String(),
		Timestamp:   time.Now().UTC(),
		Module:      event.Module,
		Type:        event.Type,
		Severity:    event.Severity,
		Status:      AlertStatusOpen,
		Title:       title,
		Description: description,
		EventIDs:    []string{event.ID},
		Metadata:    make(map[string]interface{}),
	}
}

// Marshal serializes the alert to JSON.
func (a *Alert) Marshal() ([]byte, error) {
	return json.Marshal(a)
}

// AlertHandler is a function that processes alerts.
type AlertHandler func(alert *Alert)

// AlertPipeline manages alert routing and processing.
type AlertPipeline struct {
	mu       sync.RWMutex
	handlers []AlertHandler
	alerts   []*Alert
	maxStore int
	logger   zerolog.Logger
}

// NewAlertPipeline creates a new AlertPipeline.
func NewAlertPipeline(logger zerolog.Logger, maxStore int) *AlertPipeline {
	if maxStore <= 0 {
		maxStore = 10000
	}
	return &AlertPipeline{
		handlers: make([]AlertHandler, 0),
		alerts:   make([]*Alert, 0, maxStore),
		maxStore: maxStore,
		logger:   logger.With().Str("component", "alert_pipeline").Logger(),
	}
}

// AddHandler registers an alert handler.
func (p *AlertPipeline) AddHandler(handler AlertHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()
	p.handlers = append(p.handlers, handler)
}

// Process routes an alert through all registered handlers and stores it.
func (p *AlertPipeline) Process(alert *Alert) {
	p.mu.Lock()
	if len(p.alerts) >= p.maxStore {
		// Drop oldest 10% when full
		drop := p.maxStore / 10
		p.alerts = p.alerts[drop:]
	}
	p.alerts = append(p.alerts, alert)
	handlers := make([]AlertHandler, len(p.handlers))
	copy(handlers, p.handlers)
	p.mu.Unlock()

	p.logger.Info().
		Str("alert_id", alert.ID).
		Str("module", alert.Module).
		Str("severity", alert.Severity.String()).
		Str("title", alert.Title).
		Msg("alert generated")

	for _, handler := range handlers {
		handler(alert)
	}
}

// GetAlerts returns stored alerts, optionally filtered by severity.
func (p *AlertPipeline) GetAlerts(minSeverity Severity, limit int) []*Alert {
	p.mu.RLock()
	defer p.mu.RUnlock()

	result := make([]*Alert, 0)
	count := 0
	// Iterate in reverse for most recent first
	for i := len(p.alerts) - 1; i >= 0 && count < limit; i-- {
		if p.alerts[i].Severity >= minSeverity {
			result = append(result, p.alerts[i])
			count++
		}
	}
	return result
}

// GetAlertByID returns a specific alert.
func (p *AlertPipeline) GetAlertByID(id string) *Alert {
	p.mu.RLock()
	defer p.mu.RUnlock()
	for _, a := range p.alerts {
		if a.ID == id {
			return a
		}
	}
	return nil
}

// Count returns the total number of stored alerts.
func (p *AlertPipeline) Count() int {
	p.mu.RLock()
	defer p.mu.RUnlock()
	return len(p.alerts)
}

// UpdateAlertStatus changes the status of an alert by ID.
func (p *AlertPipeline) UpdateAlertStatus(id string, status AlertStatus) (*Alert, bool) {
	p.mu.Lock()
	defer p.mu.Unlock()
	for _, a := range p.alerts {
		if a.ID == id {
			a.Status = status
			return a, true
		}
	}
	return nil, false
}

// ClearAlerts removes all stored alerts and returns the count removed.
func (p *AlertPipeline) ClearAlerts() int {
	p.mu.Lock()
	defer p.mu.Unlock()
	count := len(p.alerts)
	p.alerts = make([]*Alert, 0, p.maxStore)
	return count
}
// DeleteAlert removes a single alert by ID and returns true if found.
func (p *AlertPipeline) DeleteAlert(id string) bool {
	p.mu.Lock()
	defer p.mu.Unlock()
	for i, a := range p.alerts {
		if a.ID == id {
			p.alerts = append(p.alerts[:i], p.alerts[i+1:]...)
			return true
		}
	}
	return false
}

// ParseAlertStatus converts a string to AlertStatus.
func ParseAlertStatus(s string) (AlertStatus, bool) {
	switch strings.ToUpper(s) {
	case "OPEN":
		return AlertStatusOpen, true
	case "ACKNOWLEDGED", "ACK":
		return AlertStatusAcknowledged, true
	case "RESOLVED":
		return AlertStatusResolved, true
	case "FALSE_POSITIVE":
		return AlertStatusFalsePositive, true
	default:
		return AlertStatusOpen, false
	}
}
